# 162.Find Peak Element

### LeetCode 题目链接

[162.Find Peak Element](https://leetcode.com/problems/find-peak-element/)

### 题目大意

峰值元素是指其值严格大于左右相邻值的元素

给一个整数数组 `nums`，找到峰值元素并返回其索引

数组可能包含多个峰值，在这种情况下，返回`任何一个峰值`所在位置即可

可以假设 `nums[-1] = nums[n] = -∞`

必须实现时间复杂度为 `O(log n)` 的算法来解决此问题

```js
Example 1:
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.

Example 2:
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.
```

说明:
- 1 <= nums.length <= 1000
- -2^31 <= nums[i] <= 2^31 - 1
- nums[i] != nums[i + 1] for all valid i.

### 解题

这道题更好的思路是不要考虑 `left` 和 `right`，单纯考虑 `mid` 周边的情况

具体来说，计算 `nums[mid]` 和 `nums[mid+1]` 这两个元素的相对大小，即可得到 `mid` 附近的元素走势：
- 若走势下行（`nums[mid] > nums[mid+1]`），说明 `mid` 本身就是峰值或其左侧有一个峰值，所以需要收缩右边界（`right = mid`）
- 若走势上行（`nums[mid] < nums[mid+1]`），则说明 `mid` 右侧有一个峰值，需要收缩左边界（`left = mid + 1`）

因为题目说了 `nums` 中不存在相等的相邻元素，所以不用考虑 `nums[mid] == nums[mid+1]` 的情况，依据以上分析即可写出代码

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```
```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] > nums[mid + 1]:
                right = mid
            else:
                left = mid + 1
        return left
```
```js
var findPeakElement = function(nums) {
    let left = 0, right = nums.length - 1;
    while(left < right) {
        let mid = left + Math.floor((right - left) / 2);
        if(nums[mid] > nums[mid + 1]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
};
```
- 时间复杂度: `O(logn)`
- 空间复杂度: `O(1)`