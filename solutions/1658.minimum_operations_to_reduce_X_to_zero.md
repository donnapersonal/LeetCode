# 1658.Minimum Operations to Reduce X to Zero

### LeetCode 题目链接

[1658.Minimum Operations to Reduce X to Zero](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/)

### 题目大意

给一个整数数组 `nums` 和一个整数 `x`。每一次操作，应当移除数组 `nums` 最左边或最右边的元素，然后从 `x` 中减去该元素的值

请注意，需要`修改`数组以供接下来的操作使用

若可以将 `x` 恰好减到 `0`，返回`最小操作数`；否则，返回 `-1` 

```js
Example 1:
Input: nums = [1,1,4,2,3], x = 5
Output: 2
Explanation: The optimal solution is to remove the last two elements to reduce x to zero.

Example 2:
Input: nums = [5,6,7,8,9], x = 4
Output: -1

Example 3:
Input: nums = [3,2,20,1,1,3], x = 10
Output: 5
Explanation: The optimal solution is to remove the last three elements and the first two elements (5 operations in total) to reduce x to zero.
```

说明:
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^4
- 1 <= x <= 10^9

### 解题

注意：这道题的数据规模是 `1 <= nums.length <= 10^5`，意味着`递归`算法的时间复杂度不能达到 `O(2^n)` 这个级别，因为 `10^5` 的平方就是 `10^10`，这个数量级是不能被接受的

若使用递归算法，且不说指数级复杂度的`回溯算法`，即便能用`动态规划`算法消除重叠子问题，至少也要用两个状态即数组两端 `i`, `j` 的索引位置，则时空复杂度最起码都要 `O(2^n)`，所以这道题不适合用递归算法

这道题等价于`寻找 nums 中元素和为 sum(nums) - x 的最长子数组`

寻找子数组就得考虑到`滑动窗口`技巧
- 当窗口内元素之和小于目标和 `target` 时，扩大窗口，让窗口内元素和增加
- 当窗口内元素之和大于目标和 target 时，缩小窗口，让窗口内元素和减小
- 当窗口内元素之和等于目标和 target 时，找到一个符合条件的子数组，即要找的是最长的子数组长度

题目中 `nums` 中的元素都是正数，这就保证了只要有元素加入窗口，和一定变大，只要有元素离开窗口，和一定变小

若存在负数，就不能确定什么时候扩大和缩小窗口，也就不能使用滑动窗口算法，而应该使用`前缀和 + 哈希表`的方式解决

```java
class Solution {
    public int minOperations(int[] nums, int x) {
        int n = nums.length, sum = 0;
        for (int i = 0; i < n; i++) {
            sum += nums[i];
        }
        // 滑动窗口需要寻找的子数组目标和
        int target = sum - x;
        int left = 0, right = 0;
        int windowSum = 0;
        int maxLen = Integer.MIN_VALUE;
        
        while (right < nums.length) {
            windowSum += nums[right];
            right++;

            while (left < right && windowSum > target) {
                windowSum -= nums[left];
                left++;
            }

            if (windowSum == target) {
                maxLen = Math.max(maxLen, right - left);
            }
        }
        return maxLen == Integer.MIN_VALUE ? -1 : n - maxLen;
    }
}
```
```python
class Solution:
    def minOperations(self, nums: List[int], x: int) -> int:
        n = len(nums)
        numSum = sum(nums)
        target = numSum - x
        left = 0
        right = 0
        window_sum = 0
        max_len = float("-inf")
        while right < n:
            window_sum += nums[right]
            right += 1
            while window_sum > target and left < right:
                window_sum -= nums[left]
                left += 1
            if window_sum == target:
                max_len = max(max_len, right - left)
        
        return -1 if max_len == float("-inf") else n - max_len
```
```js
var minOperations = function(nums, x) {
    const n = nums.length;
    let sum = 0;
    for (let i = 0; i < n; i++) {
        sum += nums[i];
    }
    const target = sum - x;
    let left = 0, right = 0;
    let windowSum = 0;
    let maxLen = Number.MIN_VALUE;
    while (right < nums.length) {
        windowSum += nums[right];
        right++;
        while(left < right && windowSum > target) {
            windowSum -= nums[left];
            left++;
        }
        if(windowSum == target) {
            maxLen = Math.max(maxLen, right - left);
        }
    }
    return maxLen == Number.MIN_VALUE ? -1 : n - maxLen;
};
```
- 时间复杂度: `O(n)`
- 空间复杂度: `O(1)`



