# 217.Contains Duplicate

### LeetCode 题目链接

[217.Contains Duplicate](https://leetcode.com/problems/contains-duplicate/description/)

### 题目大意

给定一个整数数组 `nums`，判断是否存在重复元素，若有元素在数组中出现至少两次，返回 true；否则返回 false

```
Example 1:

Input: nums = [1,2,3,1]
Output: true

Example 2:

Input: nums = [1,2,3,4]
Output: false

Example 3:

Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true
```

说明：
- 1 <= nums.length <= 10^5
- -10^9 <= nums[i] <= 10^9

### 解题

#### 思路 1：哈希表

- 使用一个哈希表存储元素和对应元素数量
- 遍历元素，若哈希表中出现了该元素，则直接输出 true；若没有出现，则向哈希表中插入该元素
- 若遍历完也没发现重复元素，则输出 false

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Map<Integer, Integer> newMap = new HashMap<>();
        for (int num : nums) {
            if (newMap.containsKey(num)) {
                return true;
            } else {
                newMap.put(num, num);
            }
        }
        return false;
    }
}
```
```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        newMap = {}
        for num in nums:
            if num in newMap:
                return True
            else:
                newMap[num] = num
        return False
```
```js
var containsDuplicate = function(nums) {
    let newMap = new Map();
    for(let num of nums) {
        if (newMap.has(num)) {
            return true;
        } else {
            newMap.set(num, num);
        }
    }
    return false;
};
```
- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

#### 思路 2：排序

- 先对数组进行排序
- 排序后，遍历数组，判断相邻元素间是否出现重复元素
- 若相邻元素相同，说明出现重复元素，返回 true
- 若遍历完没发现重复元素，则输出 false

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);
        int len = nums.length;
        for(int i = 1; i < len; i ++) {
            if (nums[i - 1] == nums[i]) {
                return true;
            }
        }
        return false;
    }
}
```
```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        nums.sort()
        numsLen = len(nums)
        for i in range(1, numsLen):
            if nums[i - 1] == nums[i]:
                return True
        return False
```
```js
var containsDuplicate = function(nums) {
    nums.sort((a, b) => a - b);
    let len = nums.length;
    for(let i = 1; i < len; i++) {
        if (nums[i - 1] == nums[i]) {
            return true;
        }
    }
    return false;
};
```
- 时间复杂度：`O(nlogn)`
  > 排序的时间复杂度为 O(n log n)
  > 遍历数组进行相邻元素比较的时间复杂度为 O(n)

- 空间复杂度：`O(n)`
  > 尽管排序算法在许多情况下可以原地进行（即：O(1) 空间复杂度），但由于 Timsort 使用额外的内存来达到其性能和稳定性特点
  > 一般需要考虑最坏情况下的空间需求，因此，对于一般的实现，可认为其空间复杂度为 O(n)


