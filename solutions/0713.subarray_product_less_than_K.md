# 713.Subarray Product Less Than K

### LeetCode 题目链接

[713.Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/)

### 题目大意

给一个整数数组 `nums` 和一个整数 `k`，请返回子数组内所有元素的乘积严格小于 `k` 的连续子数组的数目

```js
Example 1:
Input: nums = [10,5,2,6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.

Example 2:
Input: nums = [1,2,3], k = 0
Output: 0
```

说明:
- 1 <= nums.length <= 3 * 10^4
- 1 <= nums[i] <= 1000
- 0 <= k <= 10^6

### 解题

使用滑动窗口算法需要搞清楚以下几个问题：
- 什么时候应该扩大窗口？
- 什么时候应该缩小窗口？
- 什么时候得到一个合法的答案？

针对该题，以上三个问题的答案是：
- 当窗口元素之积小于 k 时，扩大窗口，让积更大一些
- 当窗口元素之积大于 k 时，缩小窗口，让积更小一些
- 当窗口元素之积小于 k 时，窗口内元素的所有子数组都是合法子数组

> 注：本题之所以可用`滑动窗口`，关键是题目中指明 `nums` 中的元素都是`正数`，保证了只要有元素加入窗口，积一定变大，只要有元素离开窗口，积一定变小

> 若存在`负数`则就没有该性质，也就不能确定什么时候扩大和缩小窗口，也就不能使用滑动窗口算法，而应该使用`前缀积 + 哈希表`的算法

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int left = 0, right = 0;
        int windowProduct = 1;
        int count = 0;
        while (right < nums.length) {
            windowProduct = windowProduct * nums[right];
            right++;
            while (left < right && windowProduct >= k) {
                // 缩小窗口，并更新窗口数据
                windowProduct = windowProduct / nums[left];
                left++;
            }
            count += right - left;
        }
        return count;
    }
}
```
```python
class Solution:
    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        left = 0
        right = 0
        window_product = 1
        count = 0

        while right < len(nums):
            window_product *= nums[right]
            right += 1

            while left < right and window_product >= k:
                window_product /= nums[left]
                left += 1
            
            count += right - left
        
        return count
```
```js
var numSubarrayProductLessThanK = function(nums, k) {
    let left = 0, right = 0;
    let windowProduct = 1;
    let count = 0;

    while(right < nums.length) {
        windowProduct = windowProduct * nums[right];
        right++;
        while(left < right && windowProduct >= k) {
            windowProduct = windowProduct / nums[left];
            left++;
        }
        count += right - left;
    }
    return count;
};
```

- 时间复杂度: `O(n)`
- 空间复杂度: `O(1)`