# 349.Intersection of Two Arrays

### LeetCode 题目链接

[349.Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/)

### 题目大意

给定两个数组 `nums1` 和 `nums2`，返回它们的`交集`，输出结果中的每个元素一定是`唯一`的

可以不考虑输出结果的顺序

```js
xample 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]

Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
```

说明:
- 1 <= nums1.length, nums2.length <= 1000
- 0 <= nums1[i], nums2[i] <= 1000

### 解题

#### 思路 1: 哈希表

注意，`使用数组来做哈希的题目，是因为题目都限制了数值的大小`，而这题限制了数值范围，就可以使用数组来做哈希表

> 若哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费

遇到哈希问题直接都用 `set` 可以吗？
- 直接使用 `set` 不仅占用空间比数组大，且速度要比数组慢，`set` 把数值映射到 `key` 上都要做 `hash` 计算的
- 不要小瞧这个耗时，在数据量大的情况，差距是很明显的

```java
// 使用 HashSet
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
            return new int[0];
        }
        Set<Integer> set1 = new HashSet<>();
        Set<Integer> resSet = new HashSet<>();
        for (int i : nums1) {
            set1.add(i);
        }
        for (int i : nums2) {
            if (set1.contains(i)) {
                resSet.add(i);
            }
        }
        // 方法 1：将结果集合转为数组
        // return resSet.stream().mapToInt(x -> x).toArray();

        // 方法 2：另外申请一个数组存放setRes中的元素,最后返回数组
        int[] arr = new int[resSet.size()];
        int j = 0;

        for(int num : resSet){
            arr[j++] = num;
        }
        
        return arr;
    }
}

// 使用 Hash 數組
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        int[] hash1 = new int[1002];
        int[] hash2 = new int[1002];
        for(int i : nums1)
            hash1[i]++;
        for(int i : nums2)
            hash2[i]++;
        List<Integer> resList = new ArrayList<>();
        for(int i = 0; i < 1002; i++)
            if(hash1[i] > 0 && hash2[i] > 0)
                resList.add(i);
        int index = 0;
        int res[] = new int[resList.size()];
        for(int i : resList)
            res[index++] = i;
        return res;
    }
}
```
```python
# 使用字典和集合
# 写法 1
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        table = {}
        for num in nums1:
            table[num] = table.get(num, 0) + 1
        # 使用集合存储结果
        res = set()
        for num in nums2:
            if num in table:
                res.add(num)
                del table[num]
        return list(res)

# 写法 2
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        numDict = dict()
        nums = []
        for num in nums1:
            if num not in numDict:
                numDict[num] = 1
        for num in nums2:
            if num in numDict and numDict[num] != 0:
                numDict[num] -= 1
                nums.append(num)
        return nums

# 使用数组
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        count1 = [0] * 1001
        count2 = [0] * 1001
        res = []
        for i in range(len(nums1)):
            count1[nums1[i]] += 1
        for j in range(len(nums2)):
            count2[nums2[j]] += 1
        for k in range(1001):
            if count1[k] * count2[k] > 0:
                res.append(k)
        return res
```
```js
var intersection = function(nums1, nums2) {
    // 根据数组大小交换操作的数组
    if(nums1.length < nums2.length) {
         const _ = nums1;
         nums1 = nums2;
         nums2 = _;
    }
    const nums1Set = new Set(nums1);
    const resSet = new Set();
    // 循环比迭代器快
    for(let i = nums2.length - 1; i >= 0; i--) {
        nums1Set.has(nums2[i]) && resSet.add(nums2[i]);
    }
    return Array.from(resSet);
};
```

- 时间复杂度: `O(n + m)`
- 空间复杂度: `O(n)`s

#### 思路 2: 双指针
 
- 对数组 `nums1`、`nums2` 先排序
- 使用两个指针 `left1`、`left2`，分别指向第一个和第二个数组的第一个元素
- 若 nums1[left1] 等于 nums2[left2]，则将其加入答案数组（注意去重），`left1`、`left2` 右移
- 若 nums1[left1] 小于 nums2[left2]，`left1` 右移
- 若 nums1[left1] 大于 nums2[left2]，`left2` 右移
- 最后返回答案数组

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int left1 = 0, left2 = 0;
        List<Integer> res = new ArrayList<>();

        while(left1 < nums1.length && left2 < nums2.length) {
            if(nums1[left1] == nums2[left2]) {
                if (!res.contains(nums1[left1])) {
                    res.add(nums1[left1]);
                }
                left1++;
                left2++;
            } else if (nums1[left1] < nums2[left2]) {
                left1++;
            } else {
                left2++;
            }
        }
        // 将 List<Integer> 转换为 int[]
        int[] resultArray = new int[res.size()];
        for (int i = 0; i < res.size(); i++) {
            resultArray[i] = res.get(i);
        }

        return resultArray;
    }
}
```
```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        nums1.sort()
        nums2.sort()

        left1 = 0
        left2 = 0

        res = []

        while left1 < len(nums1) and left2 < len(nums2):
            if nums1[left1] == nums2[left2]:
                if nums1[left1] not in res:
                    res.append(nums1[left1])
                left1 += 1
                left2 += 1
            elif nums1[left1] < nums2[left2]:
                left1 += 1
            else:
                left2 += 1
        
        return res
```
```js
var intersection = function(nums1, nums2) {
    nums1.sort((a, b) => a - b);
    nums2.sort((a, b) => a - b);

    let left1 = 0;
    let left2 = 0;
    const res = [];

    while (left1 < nums1.length && left2 < nums2.length) {
        if (nums1[left1] === nums2[left2]) {
            if (!res.includes(nums1[left1])) {
                res.push(nums1[left1]);
            }
            left1++;
            left2++;
        } else if (nums1[left1] < nums2[left2]) {
            left1++;
        } else {
            left2++;
        }
    }
    return res;
};
```

- 时间复杂度: `O(n)`
- 空间复杂度: `O(1)`