# 252.Meeting Rooms

### LeetCode 题目链接

[252.Meeting Rooms](https://leetcode.cn/problems/meeting-rooms/description/)

### 题目大意

给定一个会议时间安排的数组 `intervals`，每个会议时间都会包括开始和结束的时间 `intervals[i] = [starti, endi]`，请判断一个人是否能够参加这里面的全部会议

```
Example 1：

Input：intervals = [[0,30],[5,10],[15,20]]
Output：false

Example 2：

Input：intervals = [[7,10],[2,4]]
Output：true
```

说明：
- 0 <= intervals.length <= 10^4
- intervals[i].length == 2
- 0 <= starti < endi <= 10^6

### 解题

- 先根据会议的开始时间对所有会议进行排序
- 检查每个会议的结束时间是否早于下一个会议的开始时间，若存在重叠，返回 false；否则返回 true

```java
class Solution {
    public boolean canAttendMeetings(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        int len = intervals.length;
        for (int i = 1; i < len; i++) {
            if (intervals[i][0] < intervals[i - 1][1]) {
                return false; // 存在重叠，不能参加所有会议
            }
        }
        return true;
    }
}
```
```python
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        intervals.sort(key=lambda x: x[0])
        listLen = len(intervals)
        for i in range(1, listLen):
            if intervals[i][0] < intervals[i - 1][1]:
                return False
        return True
```
```js
var canAttendMeetings = function(intervals) {
    // 按照会议的开始时间排序
    intervals.sort((a, b) => a[0] - b[0]);
    let len = intervals.length;
    for (let i = 1; i < len; i++) {
        if (intervals[i][0] < intervals[i - 1][1]) {
            return false; 
        }
    }

    return true; 
};
```
- 时间复杂度：`O(nlog n)`
- 空间复杂度：`O(1)`
  > 若忽略排序算法的内部实现（即假设为原地排序，如堆排序），其空间复杂度可以视为 O(1)
  > 
  > 若考虑排序的实际实现，特别是基于 Timsort 的实现，其空间复杂度可以是 O(n)