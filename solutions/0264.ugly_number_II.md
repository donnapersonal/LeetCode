# 264.Ugly Number II

### LeetCode 题目链接

[264.Ugly Number II](https://leetcode.com/problems/ugly-number-ii/)

### 题目大意

给一个整数 `n`，请找出并返回第 `n` 个`丑数`

`丑数`就是质因子只包含 `2、3 和 5` 的正整数

```js
Example 1:
Input: n = 10
Output: 12
Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.

Example 2:
Input: n = 1
Output: 1
Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.
```

说明:
- 1 <= n <= 1690

### 解题

#### 思路 1: 双指针

若一个数 `x` 是丑数，则 `x * 2`/`x * 3`/`x * 5` 都一定是丑数

把所有丑数想象成一个从小到大排序的链表，就是这个样子：`1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 8 -> ...`

可以把丑数分为三类：`2 的倍数`、`3 的倍数`、`5 的倍数`（按照题目的意思，`1` 算作特殊的丑数，放在开头），这三类丑数就好像三条有序链表，如下
- 能被 `2` 整除的丑数：`1 -> 1*2 -> 2*2 -> 3*2 -> 4*2 -> 5*2 -> 6*2 -> 8*2 ->...`
- 能被 `3` 整除的丑数：`1 -> 1*3 -> 2*3 -> 3*3 -> 4*3 -> 5*3 -> 6*3 -> 8*3 ->...`
- 能被 `5` 整除的丑数：`1 -> 1*5 -> 2*5 -> 3*5 -> 4*5 -> 5*5 -> 6*5 -> 8*5 ->...`

把这三条`有序链表`合并在一起并去重，其结果就是丑数的序列，然后求合并后的这条有序链表中第 `n` 个元素是什么

```java
class Solution {
    public int nthUglyNumber(int n) {
        int p2 = 1, p3 = 1, p5 = 1;
        int product2 = 1, product3 = 1, product5 = 1;
        int[] ugly = new int[n + 1];
        int p = 1;
        while (p <= n) {
            int min = Math.min(Math.min(product2, product3), product5);
            ugly[p] = min;
            p++;
            if (min == product2) {
                product2 = 2 * ugly[p2];
                p2++;
            }
            if (min == product3) {
                product3 = 3 * ugly[p3];
                p3++;
            }
            if (min == product5) {
                product5 = 5 * ugly[p5];
                p5++;
            }
        }
        return ugly[n];
    }
}
```
```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        # 三个指向有序链表头结点的指针
        p2, p3, p5 = 1, 1, 1
        # 三个有序链表的头节点的值
        product2, product3, product5 = 1, 1, 1
        # 最终合并的有序链表（结果链表）
        ugly = [0] * (n + 1)
        # 结果链表上的指针
        p = 1

        # 开始合并三个有序链表
        while p <= n:
            # 取三个链表的最小结点
            minVal = min(product2, product3, product5)
            # 接到结果链表上
            ugly[p] = minVal
            p += 1
            # 前进对应有序链表上的指针
            if minVal == product2:
                product2 = 2 * ugly[p2]
                p2 += 1
            if minVal == product3:
                product3 = 3 * ugly[p3]
                p3 += 1
            if minVal == product5:
                product5 = 5 * ugly[p5]
                p5 += 1
        
        # 返回第 n 个丑数
        return ugly[n]
```
```js
var nthUglyNumber = function(n) {
    let p2 = 1, p3 = 1, p5 = 1;
    let product2 = 1, product3 = 1, product5 = 1;
    let ugly = new Array(n + 1);
    let p = 1;

    while(p <= n) {
        let min = Math.min(Math.min(product2, product3), product5);
        ugly[p] = min;
        p++;
        if (min === product2) {
            product2 = 2 * ugly[p2];
            p2++;
        }
        if (min === product3) {
            product3 = 3 * ugly[p3];
            p3++;
        }
        if (min === product5) {
            product5 = 5 * ugly[p5];
            p5++;
        }
    }
    return ugly[n];
};
```
- 时间复杂度: `O(n)`，主要的 `while` 循环运行 `n` 次，每次循环内的操作都是常数时间
- 空间复杂度: `O(n)`，需要一个长度为 `n+1` 的数组来存储丑数

#### 思路 2: DP

定义状态 `dp[i]` 表示第 `i` 个丑数

状态转移方程为：`dp[i] = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)`，其中 `p2`、`p3`、`p5` 分别表示当前 `i` 中 `2、3、5` 的质因子数量

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for (int i = 1; i < n; i++) {
            dp[i] = Math.min(dp[p2] * 2, Math.min(dp[p3] * 3, dp[p5] * 5));
            if (dp[i] == dp[p2] * 2) p2++;
            if (dp[i] == dp[p3] * 3) p3++;
            if (dp[i] == dp[p5] * 5) p5++;
        }
        return dp[n - 1];
    }
}
```
```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        dp = [1 for _ in range(n)]
        p2, p3, p5 = 0, 0, 0
        for i in range(1, n):
            dp[i] = min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5)
            if dp[i] == dp[p2] * 2:
                p2 += 1
            if dp[i] == dp[p3] * 3:
                p3 += 1
            if dp[i] == dp[p5] * 5:
                p5 += 1
        return dp[n - 1]
```
```js
var nthUglyNumber = function(n) {
    const dp = new Array(n).fill(1);
    let p2 = 0, p3 = 0, p5 = 0;
    for (let i = 1; i < n; i++) {
        dp[i] = Math.min(dp[p2] * 2, dp[p3] * 3, dp[p5] * 5);
        if (dp[i] === dp[p2] * 2) p2++;
        if (dp[i] === dp[p3] * 3) p3++;
        if (dp[i] === dp[p5] * 5) p5++;
    }
    return dp[n - 1];
};
```
- 时间复杂度: `O(n)`，主要的 `for` 循环运行 `n−1` 次，每次循环内的操作都是常数时间
- 空间复杂度: `O(n)`，需要一个长度为 `n` 的数组来存储丑数