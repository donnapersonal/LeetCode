# 209.Minimum Size Subarray Sum

### LeetCode 题目链接

[209.Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)

### 题目大意

给定一个含有 `n` 个正整数的数组和一个正整数 `target` 

找出该数组中满足其总和大于等于 `target` 的长度最小的子数组 `[numsl, numsl+1, ..., numsr-1, numsr]`，并返回其长度，若不存在符合条件的子数组，返回 `0`

```js
Example 1:
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.

Example 2:
Input: target = 4, nums = [1,4,4]
Output: 1

Example 3:
Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0
```

说明:
- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^4

### 解题

#### 思路 1: 暴力解法

两个 `for` 循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是 `O(n^2)`，空间复杂度是 `O(1)`

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        l = len(nums)
        min_len = float('inf')
        for i in range(l):
            cur_sum = 0
            for j in range(i, l):
                cur_sum += nums[j]
                if cur_sum >= target:
                    min_len = min(min_len, j - i + 1)
                    break
        
        return min_len if min_len != float('inf') else 0
```

#### 思路 2: 滑动窗口

- 窗口：满足其和 `≥ s` 的长度最小的连续子数组
- 窗口的起始位置如何移动：若当前窗口的值大于 `s`，窗口要向前移动（即缩小窗口）
- 窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，即 `for` 循环里的索引

> 滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置，从而将 `O(n^2)` 暴力解法降为 `O(n)`

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int sum = 0;
        int res = Integer.MAX_VALUE;
        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            while (sum >= target) {
                res = Math.min(res, right - left + 1);
                sum -= nums[left++];
            }
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }
}
```
```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        right = 0
        sum = 0
        l = len(nums)
        min_len = float('inf')
        while right < l:
            sum += nums[right]
            while sum >= target:
                min_len = min(min_len, right - left + 1)
                sum -= nums[left]
                left += 1

            right += 1
        return min_len if min_len != float('inf') else 0
```
```js
var minSubArrayLen = function(target, nums) {
    let left = 0, right = 0;
    let sum = 0
    let len = nums.length;
    let ans = Infinity;
    while(right < len) {
        sum += nums[right];
        while(sum >= target) {
            ans = Math.min(ans, right - left + 1);
            sum -= nums[left];
            left++;
        }
        right++;
    }
    return ans == Infinity ? 0 : ans;
};
```

- 时间复杂度: `O(n)`
  > 注意：不要以为 `for` 里放一个 `while` 就以为是 `O(n^2)`， 主要是看每个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 `2 × n` 即 `O(n)`
- 空间复杂度: `O(1)`

